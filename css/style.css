// script.js - Full JavaScript implementation for Scratch-like interface

document.addEventListener('DOMContentLoaded', function() {
    // Global variables
    let isDragging = false;
    let dragStartX, dragStartY;
    let initialCharacterX, initialCharacterY;
    let currentCategory = 'triggering'; // Default active category
    
    // DOM elements
    const character = document.getElementById('character');
    const stage = document.getElementById('stage');
    const gridToggle = document.getElementById('grid-toggle');
    const categoryTabs = document.querySelectorAll('.category-tab');
    const blockCategories = document.querySelectorAll('.block-category');
    const clearAllButton = document.getElementById('clear-all');
    const programBlocks = document.getElementById('program-blocks');
    
    // Initialize the interface
    initializeInterface();
    
    // Initialize the character
    initializeCharacter();
    
    // Initialize grid toggle
    initializeGridToggle();
    
    // Initialize drag-and-drop functionality
    initializeDragAndDrop();
    
    // Initialize block palette
    initializeBlockPalette();
    
    // Initialize programming area
    initializeProgrammingArea();
    
    // Functions
    
    function initializeInterface() {
        // Show default category
        showCategory(currentCategory);
        
        // Set up category tab click handlers
        categoryTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                const category = this.getAttribute('data-category');
                showCategory(category);
            });
        });
        
        // Set up clear all button
        if (clearAllButton) {
            clearAllButton.addEventListener('click', clearAllBlocks);
        }
    }
    
    function initializeCharacter() {
        // Set initial character position (center of stage)
        character.style.left = '50%';
        character.style.top = '50%';
        
        // Make character draggable
        character.addEventListener('mousedown', characterDragStart);
    }
    
    function initializeGridToggle() {
        if (gridToggle) {
            gridToggle.addEventListener('click', function() {
                stage.classList.toggle('show-grid');
                this.textContent = stage.classList.contains('show-grid') ? 'Hide Grid' : 'Show Grid';
            });
        }
    }
    
    function initializeDragAndDrop() {
        // Add block drag start handlers to all blocks in palette
        const paletteBlocks = document.querySelectorAll('#block-palette .scratch-block');
        paletteBlocks.forEach(block => {
            block.addEventListener('mousedown', blockDragStart);
        });
    }
    
    function initializeBlockPalette() {
        // Create blocks for each category
        createBlocksForCategory('triggering', [
            { type: 'when-clicked', icon: 'click.svg', text: '' },
            { type: 'when-key-pressed', icon: 'key.svg', text: '' }
        ]);
        
        createBlocksForCategory('motion', [
            { type: 'move-forward', icon: 'forward.svg', text: '' },
            { type: 'turn-right', icon: 'right.svg', text: '' },
            { type: 'turn-left', icon: 'left.svg', text: '' }
        ]);
        
        createBlocksForCategory('looks', [
            { type: 'say-hello', icon: 'speech.svg', text: '' },
            { type: 'grow', icon: 'grow.svg', text: '' },
            { type: 'shrink', icon: 'shrink.svg', text: '' }
        ]);
        
        createBlocksForCategory('sound', [
            { type: 'play-sound', icon: 'sound.svg', text: '' },
            { type: 'stop-sound', icon: 'mute.svg', text: '' }
        ]);
        
        createBlocksForCategory('control', [
            { type: 'wait', icon: 'clock.svg', text: '' },
            { type: 'repeat', icon: 'loop.svg', text: '3' }
        ]);
        
        createBlocksForCategory('end', [
            { type: 'end-block', icon: 'stop.svg', text: '' }
        ]);
    }
    
    function initializeProgrammingArea() {
        // Set up drop zone
        programBlocks.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
        
        programBlocks.addEventListener('drop', function(e) {
            e.preventDefault();
            const blockData = e.dataTransfer.getData('text/plain');
            const blockInfo = JSON.parse(blockData);
            addBlockToProgrammingArea(blockInfo);
        });
    }
    
    function showCategory(category) {
        // Update active category
        currentCategory = category;
        
        // Hide all categories
        blockCategories.forEach(cat => {
            cat.classList.remove('active');
        });
        
        // Show selected category
        const selectedCategory = document.getElementById(`${category}-blocks`);
        if (selectedCategory) {
            selectedCategory.classList.add('active');
        }
        
        // Update active tab
        categoryTabs.forEach(tab => {
            tab.classList.remove('active');
        });
        
        const selectedTab = document.querySelector(`.category-tab[data-category="${category}"]`);
        if (selectedTab) {
            selectedTab.classList.add('active');
        }
    }
    
    function createBlocksForCategory(category, blocks) {
        const categoryElement = document.getElementById(`${category}-blocks`);
        if (!categoryElement) return;
        
        blocks.forEach(block => {
            const blockContainer = document.createElement('div');
            blockContainer.className = 'block-container';
            blockContainer.setAttribute('data-type', block.type);
            blockContainer.setAttribute('data-category', category);
            blockContainer.draggable = true;
            
            const scratchBlock = document.createElement('div');
            scratchBlock.className = 'scratch-block';
            scratchBlock.setAttribute('data-type', block.type);
            scratchBlock.setAttribute('data-category', category);
            
            if (block.icon) {
                const blockIcon = document.createElement('img');
                blockIcon.className = 'block-icon-img';
                blockIcon.src = `images/${block.icon}`;
                blockIcon.alt = block.type;
                scratchBlock.appendChild(blockIcon);
            }
            
            if (block.text) {
                const textNode = document.createTextNode(block.text);
                scratchBlock.appendChild(textNode);
            }
            
            blockContainer.appendChild(scratchBlock);
            categoryElement.appendChild(blockContainer);
            
            // Add drag start event
            blockContainer.addEventListener('dragstart', function(e) {
                const blockData = {
                    type: block.type,
                    category: category,
                    icon: block.icon,
                    text: block.text
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(blockData));
            });
        });
    }
    
    function addBlockToProgrammingArea(blockInfo) {
        const blockContainer = document.createElement('div');
        blockContainer.className = 'block-container';
        blockContainer.setAttribute('data-type', blockInfo.type);
        blockContainer.setAttribute('data-category', blockInfo.category);
        
        const scratchBlock = document.createElement('div');
        scratchBlock.className = 'scratch-block';
        scratchBlock.setAttribute('data-type', blockInfo.type);
        scratchBlock.setAttribute('data-category', blockInfo.category);
        
        if (blockInfo.icon) {
            const blockIcon = document.createElement('img');
            blockIcon.className = 'block-icon-img';
            blockIcon.src = `images/${blockInfo.icon}`;
            blockIcon.alt = blockInfo.type;
            scratchBlock.appendChild(blockIcon);
        }
        
        if (blockInfo.text) {
            const textNode = document.createTextNode(blockInfo.text);
            scratchBlock.appendChild(textNode);
        }
        
        blockContainer.appendChild(scratchBlock);
        programBlocks.appendChild(blockContainer);
        
        // Make the block in program area draggable for repositioning
        blockContainer.draggable = true;
        blockContainer.addEventListener('dragstart', function(e) {
            e.dataTransfer.setData('text/plain', JSON.stringify(blockInfo));
            // Mark for removal after dropping elsewhere
            this.classList.add('being-dragged');
        });
        
        blockContainer.addEventListener('dragend', function(e) {
            if (this.classList.contains('being-dragged')) {
                this.classList.remove('being-dragged');
            }
        });
    }
    
    function clearAllBlocks() {
        while (programBlocks.firstChild) {
            programBlocks.removeChild(programBlocks.firstChild);
        }
    }
    
    // Character Dragging Functions
    
    function characterDragStart(e) {
        e.preventDefault();
        isDragging = true;
        
        // Get initial mouse position
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        
        // Get initial character position
        const characterStyle = window.getComputedStyle(character);
        initialCharacterX = parseFloat(characterStyle.left) || 50;
        initialCharacterY = parseFloat(characterStyle.top) || 50;
        
        // Add event listeners for drag
        document.addEventListener('mousemove', characterDragMove);
        document.addEventListener('mouseup', characterDragEnd);
    }
    
    function characterDragMove(e) {
        if (!isDragging) return;
        
        // Calculate movement
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;
        
        // Get stage dimensions
        const stageRect = stage.getBoundingClientRect();
        
        // Calculate new position as percentage of stage
        let newX = initialCharacterX + (deltaX / stageRect.width * 100);
        let newY = initialCharacterY + (deltaY / stageRect.height * 100);
        
        // Update character position
        character.style.left = newX + '%';
        character.style.top = newY + '%';
        
        // Check boundaries
        keepCharacterInBounds();
    }
    
    function characterDragEnd() {
        isDragging = false;
        document.removeEventListener('mousemove', characterDragMove);
        document.removeEventListener('mouseup', characterDragEnd);
        
        // Final boundary check
        keepCharacterInBounds();
    }
    
    // Block Dragging Functions
    
    function blockDragStart(e) {
        const blockContainer = this.closest('.block-container');
        if (blockContainer) {
            blockContainer.draggable = true;
            
            const blockType = blockContainer.getAttribute('data-type');
            const blockCategory = blockContainer.getAttribute('data-category');
            
            const blockData = {
                type: blockType,
                category: blockCategory,
                icon: this.querySelector('.block-icon-img')?.src?.split('/').pop() || null,
                text: this.textContent.trim()
            };
            
            e.dataTransfer.setData('text/plain', JSON.stringify(blockData));
        }
    }
    
    // Character Movement Functions
    
    function moveCharacter(direction, steps) {
        // Get current position
        const characterStyle = window.getComputedStyle(character);
        let posX = parseFloat(characterStyle.left) || 50;
        let posY = parseFloat(characterStyle.top) || 50;
        
        // Calculate movement based on direction
        switch (direction) {
            case 'up':
                posY -= steps;
                break;
            case 'down':
                posY += steps;
                break;
            case 'left':
                posX -= steps;
                break;
            case 'right':
                posX += steps;
                break;
        }
        
        // Update character position
        character.style.left = posX + '%';
        character.style.top = posY + '%';
        
        // Check boundaries
        keepCharacterInBounds();
    }
    
    // Character Boundary Functions
    
    function keepCharacterInBounds() {
        // Get character dimensions
        const characterRect = character.getBoundingClientRect();
        const characterWidth = characterRect.width;
        const characterHeight = characterRect.height;
        
        // Get stage dimensions
        const stageRect = stage.getBoundingClientRect();
        const stageWidth = stageRect.width;
        const stageHeight = stageRect.height;
        
        // Get current position (as percentage of stage)
        let position = {
            x: parseFloat(character.style.left) || 50,
            y: parseFloat(character.style.top) || 50
        };
        
        // Calculate actual pixel positions
        const characterX = (position.x / 100) * stageWidth;
        const characterY = (position.y / 100) * stageHeight;
        
        // Boundary checks according to requirements
        
        // Left boundary check (x = 0)
        if (characterX - (characterWidth / 2) < 0) {
            // Stop exactly at left boundary
            position.x = (characterWidth / 2 / stageWidth) * 100;
        }
        
        // Top boundary check (y = 0)
        if (characterY - (characterHeight / 2) < 0) {
            // Stop exactly at top boundary
            position.y = (characterHeight / 2 / stageHeight) * 100;
        }
        
        // Right boundary check (right edge at stage boundary)
        if (characterX + (characterWidth / 2) > stageWidth) {
            // Stop with right edge exactly at boundary
            position.x = ((stageWidth - characterWidth / 2) / stageWidth) * 100;
        }
        
        // Bottom boundary check (bottom edge at stage boundary)
        if (characterY + (characterHeight / 2) > stageHeight) {
            // Stop with bottom edge exactly at boundary
            position.y = ((stageHeight - characterHeight / 2) / stageHeight) * 100;
        }
        
        // Update character position
        character.style.left = position.x + '%';
        character.style.top = position.y + '%';
    }
    
    // Run program functions
    
    function runProgram() {
        const blocks = programBlocks.querySelectorAll('.block-container');
        
        // Logic to run the program based on blocks
        // This is a placeholder for actual execution logic
        blocks.forEach(block => {
            const blockType = block.getAttribute('data-type');
            const blockCategory = block.getAttribute('data-category');
            
            // Execute block based on type
            executeBlock(blockType, blockCategory);
        });
    }
    
    function executeBlock(type, category) {
        // Implementation would depend on the actual blocks and their functionality
        switch (type) {
            case 'move-forward':
                moveCharacter('right', 5);
                break;
            case 'turn-right':
                // Implement turning right
                break;
            case 'turn-left':
                // Implement turning left
                break;
            // Add cases for other block types
        }
    }
});
